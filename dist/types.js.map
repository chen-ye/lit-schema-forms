{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { JSONSchema as StandardJSONSchema } from 'json-schema-typed';\n\n// Our application generally assumes the schema is an object (with .type, .properties etc.)\n// Standard JSON Schema allows it to be a boolean (true/false), but we exclude that for our internal usages\n// to prevent TS errors when accessing properties.\nexport type JSONSchema = Extract<StandardJSONSchema, object>;\n\nexport interface UISchema {\n  [key: string]: unknown; // Can contain nested UI config or string properties\n  'ui:widget'?: string;\n  'ui:title'?: string;\n  'ui:description'?: string;\n  'ui:help'?: string;\n  'ui:placeholder'?: string;\n  'ui:disabled'?: boolean;\n}\n\nexport type FormData = unknown; // Recursively defined JSON value, usually.\n\nexport type ChangeHandler = (value: FormData) => void;\nexport type KeyChangeHandler = (key: string, value: FormData) => void;\n\nexport type WidgetRenderer = (\n  key: string,\n  schema: JSONSchema,\n  value: unknown,\n  onChange: KeyChangeHandler,\n  view: UISchema,\n  path: string,\n  errors: import('./utils/validator.js').ValidationError[],\n  widgets: WidgetRegistry, // Circular reference if we are not careful? No, interface allows it.\n) => import('lit').TemplateResult;\n\nexport interface WidgetRegistry {\n  [key: string]: WidgetRenderer;\n}\n\n// Helper for Lit events\nexport interface InputEvent extends Event {\n  target: HTMLInputElement & { value: string };\n}\n"]}